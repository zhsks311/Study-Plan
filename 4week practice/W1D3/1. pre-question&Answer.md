##질문
Q1. Java Memory Model의 본질
"Happens-Before 관계가 단순히 '실행 순서'를 넘어서 메모리 가시성(Visibility)과 어떻게 연결되며, volatile 키워드가 이를 어떻게 보장하는지 JMM 관점에서 설명해주세요."
Q2. ThreadLocal의 설계 철학
"ThreadLocal이 WeakReference를 사용하는 이유와, Thread Pool 환경에서 ThreadLocal 사용 시 발생할 수 있는 메모리 누수의 메커니즘을 설명해주세요."
Q3. @Async와 트랜잭션 경계
"@Transactional과 @Async를 같은 메서드에 적용했을 때 왜 트랜잭션이 제대로 동작하지 않으며, 이를 해결하기 위한 아키텍처 패턴은 무엇인가요?"
Q4. 동시성 제어 전략
"Optimistic Locking에서 Version 필드를 사용하는 것과 Timestamp를 사용하는 것의 트레이드오프는? ABA Problem과의 연관성은?"
Q5. 분산 트랜잭션의 한계
"2PC(Two-Phase Commit)의 이론적 한계와 왜 현대 마이크로서비스에서 Saga 패턴을 선호하는지 CAP 정리 관점에서 설명해주세요."

## 답

1. Happends-Before 관계에 대해 정확히 모르겠어. 그런데 메모리 가시성과 volatile 에 대해서는 volatile 을 사용하면 캐시를 거치지 않은 실제 값에 바로 접근해서 값을 가져올 수 있기 때문에 값 확인 당시의 실제 값을 확인할 수 있다는 것을 알고 있어. 이게 중요한 이유는 race condition 상황에서 가장 최신의 값을 문제없이 확인할 수 있는 수단이기 때문이야.
2. 모르겠어.
3. @Async 를 적용하면 새로운 스레드를 만들어 처리하기 때문에 별개의 트랜잭션이 동작하게 돼. 해결 방법은 잘 모르겠어.
4. 모르겠어.
5. 모르겠어.
