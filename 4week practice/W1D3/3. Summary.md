# 📚 Java 동시성과 멀티스레드 트랜잭션 완벽 가이드

> **1주차 3일차**: Java Concurrency, Thread Safety, Transaction in Multi-threaded Environment
> 
> 8년차 시니어 개발자를 위한 심화 학습 자료

---

## 📋 목차

1. [Java Memory Model과 Happens-Before](#1-java-memory-model과-happens-before)
2. [Thread Safety 설계 원칙](#2-thread-safety-설계-원칙)
3. [ThreadLocal 완벽 이해](#3-threadlocal-완벽-이해)
4. [WeakReference와 메모리 관리](#4-weakreference와-메모리-관리)
5. [Spring @Async와 트랜잭션](#5-spring-async와-트랜잭션)
6. [실무 트러블슈팅 가이드](#6-실무-트러블슈팅-가이드)
7. [유명 라이브러리의 동시성 패턴](#7-유명-라이브러리의-동시성-패턴)

---

## 1. Java Memory Model과 Happens-Before

### 1.1 CPU와 메모리 구조의 이해

현대 CPU는 성능 최적화를 위해 다층 캐시 구조를 사용합니다:

```
[CPU Core 1]          [CPU Core 2]
    ↓                     ↓
[L1 Cache]           [L1 Cache]  ← 각 코어 전용
    ↓                     ↓
[L2 Cache]           [L2 Cache]
    ↓                     ↓
    [L3 Cache (공유)]
           ↓
    [Main Memory]
```

**문제점**: 각 코어가 독립적인 캐시를 가지므로 **가시성(Visibility)** 문제 발생

### 1.2 Happens-Before 관계란?

**정의**: "A happens-before B"는 A의 모든 결과를 B가 볼 수 있음을 보장하는 메모리 가시성 규칙

### 1.3 Java의 5가지 핵심 Happens-Before 규칙

#### 1) Program Order Rule
- 같은 스레드 내에서는 코드 순서대로 happens-before 관계 성립

#### 2) Volatile Variable Rule
```java
class VolatileExample {
    int a = 0;
    volatile boolean flag = false;
    
    // Thread A
    void writer() {
        a = 42;        // 1
        flag = true;   // 2 (volatile write - Memory Fence)
    }
    
    // Thread B  
    void reader() {
        if (flag) {    // 3 (volatile read)
            // flag가 true면, a는 반드시 42 보장
            System.out.println(a); // 4
        }
    }
}
```

**핵심**: volatile 쓰기 이전의 모든 변경사항이 volatile 읽기 이후에 가시화됨

#### 3) Thread Start Rule
```java
public class ThreadStartExample {
    static int sharedData = 0;
    static String message = null;
    
    public static void main(String[] args) {
        sharedData = 100;        // ① Main Thread
        message = "Hello";       // ② Main Thread
        
        Thread worker = new Thread(() -> {
            // start() 호출 덕분에 ①, ②의 결과를 볼 수 있음
            System.out.println(message);     // "Hello" 보장
            System.out.println(sharedData);  // 100 보장
        });
        
        worker.start();  // ③ 메모리 동기화 지점!
    }
}
```

**중요**: Thread.start()는 **단방향** 동기화 (Parent → Child만 보장)

#### 4) Thread Join Rule
```java
public class ThreadJoinExample {
    static int result = 0;
    
    public static void main(String[] args) throws InterruptedException {
        Thread calculator = new Thread(() -> {
            for (int i = 1; i <= 100; i++) {
                result += i;  // 계산 수행
            }
        });
        
        calculator.start();
        calculator.join();  // calculator의 모든 변경사항이 가시화됨
        
        System.out.println("Result: " + result);  // 5050 보장
    }
}
```

**Fork-Join 패턴**:
```java
class ParallelProcessor {
    public int processInParallel(List<Integer> data) throws InterruptedException {
        final int[] leftSum = new int[1];
        final int[] rightSum = new int[1];
        
        Thread leftThread = new Thread(() -> 
            leftSum[0] = processLeft(data));
        Thread rightThread = new Thread(() -> 
            rightSum[0] = processRight(data));
        
        leftThread.start();
        rightThread.start();
        
        leftThread.join();   // 왼쪽 결과 동기화
        rightThread.join();  // 오른쪽 결과 동기화
        
        return leftSum[0] + rightSum[0];  // 안전하게 사용 가능
    }
}
```

#### 5) Synchronized Rule
```java
class BankAccount {
    private int balance = 0;
    private final Object lock = new Object();
    
    void deposit(int amount) {
        synchronized (lock) {
            balance += amount;
        }  // unlock: 모든 변경사항 flush
    }
    
    int getBalance() {
        synchronized (lock) {  // lock: 이전 unlock의 모든 변경사항 visible
            return balance;
        }
    }
}
```

**핵심**: 같은 락에 대해, 이전 unlock은 다음 lock보다 happens-before

---

## 2. Thread Safety 설계 원칙

### 2.1 Immutability (불변성)
- 객체 생성 후 상태 변경 불가
- Thread-safe by design
- 추가 동기화 불필요

### 2.2 Thread Confinement (스레드 한정)
- **Stack Confinement**: 지역 변수 사용
- **ThreadLocal Storage**: 스레드별 독립 저장소
- **Ad-hoc Confinement**: 단일 스레드에서만 접근 보장

### 2.3 Safe Publication (안전한 공개)
- volatile 필드 사용
- final 필드 사용
- 동기화된 접근자 메서드

---

## 3. ThreadLocal 완벽 이해

### 3.1 ThreadLocal이란?

**비유**: 각 스레드가 가진 개인 사물함

```java
public class UserContext {
    private static final ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public static void setUser(User user) {
        currentUser.set(user);
    }
    
    public static User getUser() {
        return currentUser.get();
    }
    
    public static void clear() {
        currentUser.remove();  // 중요: 메모리 누수 방지
    }
}
```

### 3.2 내부 구조

```java
// java.lang.Thread 클래스
public class Thread implements Runnable {
    // 각 Thread가 자신만의 ThreadLocalMap을 보유
    ThreadLocal.ThreadLocalMap threadLocals = null;
}

// ThreadLocal의 get() 메서드
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = t.threadLocals;  // Thread 객체에서 가져옴
    
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            return (T)e.value;
        }
    }
    return setInitialValue();
}
```

**메모리 구조**:
```
Thread-1                    Thread-2
├─ threadLocals            ├─ threadLocals
   (ThreadLocalMap)           (ThreadLocalMap)
   ├─ Entry[0]                ├─ Entry[0]
   │  key: ThreadLocal@123    │  key: ThreadLocal@123
   │  value: "User1"          │  value: "User2"
   └─ Entry[1]                └─ Entry[1]
      key: ThreadLocal@456       key: ThreadLocal@456
      value: "TxnA"              value: "TxnB"
```

### 3.3 Thread Pool에서의 위험

```java
@RestController
public class UserController {
    private static final ThreadLocal<User> userContext = new ThreadLocal<>();
    
    @GetMapping("/api/user")
    public String handleRequest() {
        try {
            userContext.set(getCurrentUser());
            // 비즈니스 로직
            return "Success";
        } finally {
            userContext.remove();  // ⚠️ 필수! Thread Pool에서 재사용되므로
        }
    }
}
```

**문제 시나리오**:
1. Thread Pool의 Thread는 재사용됨
2. remove()를 하지 않으면 다음 요청에서 이전 데이터 접근 가능
3. **보안 문제 + 메모리 누수** 발생

---

## 4. WeakReference와 메모리 관리

### 4.1 Java의 Reference 종류

```java
// 1. Strong Reference (절대 GC 안됨)
String strong = new String("Strong");

// 2. Weak Reference (GC시 즉시 수거)
WeakReference<String> weak = new WeakReference<>(new String("Weak"));

// 3. Soft Reference (메모리 부족시만 GC)
SoftReference<String> soft = new SoftReference<>(new String("Soft"));

// 4. Phantom Reference (이미 수거된 객체 추적)
PhantomReference<String> phantom = new PhantomReference<>(new String("Phantom"), queue);
```

### 4.2 WeakReference 동작 원리

**일상적 비유**:
- **Strong Reference** = 정식 열쇠 (절대 집 철거 불가)
- **Weak Reference** = 임시 출입증 (정식 열쇠 없으면 철거 가능)

### 4.3 ThreadLocal이 WeakReference를 사용하는 이유

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
    
    Entry(ThreadLocal<?> k, Object v) {
        super(k);  // key를 WeakReference로
        value = v; // value는 strong reference
    }
}
```

**이유**: ThreadLocal 인스턴스(key)가 GC되어도 Thread가 살아있으면 value가 메모리에 남는 문제 방지

**하지만 주의**:
- key(ThreadLocal)는 GC 가능
- value는 여전히 strong reference
- 따라서 **remove() 호출 필수!**

---

## 5. Spring @Async와 트랜잭션

### 5.1 @Async + @Transactional 문제

```java
@Service
public class OrderService {
    @Async
    @Transactional  // ⚠️ 동작하지 않음!
    public void processOrder(Long orderId) {
        // 새로운 스레드 = 새로운 ThreadLocal = 트랜잭션 컨텍스트 없음
    }
}
```

**문제 원인**:
- Spring 트랜잭션은 `TransactionSynchronizationManager`의 ThreadLocal 사용
- @Async는 다른 스레드에서 실행
- ThreadLocal은 스레드간 공유 불가

### 5.2 해결 패턴

#### 패턴 1: TransactionalEventListener 사용
```java
@Service
@Transactional
public class OrderService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void createOrder(Order order) {
        orderRepository.save(order);
        eventPublisher.publishEvent(new OrderCreatedEvent(order));
    }
}

@Component
public class OrderEventListener {
    @Async
    @EventListener
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 트랜잭션 커밋 후 비동기 실행
        sendEmail(event.getOrder());
    }
}
```

#### 패턴 2: CompletableFuture 활용
```java
@Service
public class OrderService {
    @Transactional
    public Order createOrder(Order order) {
        return orderRepository.save(order);
    }
    
    public CompletableFuture<Void> processOrderAsync(Long orderId) {
        return CompletableFuture.runAsync(() -> {
            // 별도 트랜잭션으로 처리
            orderProcessor.process(orderId);
        });
    }
}
```

#### 패턴 3: 메시지 큐 활용
```java
@Service
@Transactional
public class OrderService {
    public void createOrder(Order order) {
        orderRepository.save(order);
        kafkaTemplate.send("order-topic", order);  // 트랜잭션 커밋 후 발송
    }
}

@KafkaListener(topics = "order-topic")
public void processOrder(Order order) {
    // 독립적인 트랜잭션으로 처리
}
```

---

## 6. 실무 트러블슈팅 가이드

### 6.1 ThreadLocal 메모리 누수

#### 증상
- OutOfMemoryError 발생
- 힙 덤프에서 ThreadLocal 값 대량 발견
- GC 후에도 메모리 해제 안됨

#### 원인
```java
@RestController
public class LeakyController {
    private static ThreadLocal<byte[]> memoryLeaker = new ThreadLocal<>();
    
    @GetMapping("/leak")
    public String leak() {
        byte[] bigArray = new byte[10 * 1024 * 1024];  // 10MB
        memoryLeaker.set(bigArray);
        // ⚠️ remove() 호출 안함!
        return "Leaked 10MB";
    }
}
```

#### 모니터링 코드
```java
@Component
@Slf4j
public class ThreadLocalMonitor {
    
    @Scheduled(fixedDelay = 60000)
    public void checkThreadLocals() {
        Thread[] threads = new Thread[Thread.activeCount()];
        Thread.enumerate(threads);
        
        for (Thread thread : threads) {
            analyzeThread(thread);
        }
    }
    
    private void analyzeThread(Thread thread) {
        try {
            Field threadLocalsField = Thread.class.getDeclaredField("threadLocals");
            threadLocalsField.setAccessible(true);
            Object threadLocalMap = threadLocalsField.get(thread);
            
            if (threadLocalMap != null) {
                Class<?> tlmClass = threadLocalMap.getClass();
                Field tableField = tlmClass.getDeclaredField("table");
                tableField.setAccessible(true);
                Object[] table = (Object[]) tableField.get(threadLocalMap);
                
                int count = 0;
                long totalSize = 0;
                
                for (Object entry : table) {
                    if (entry != null) {
                        count++;
                        totalSize += estimateSize(entry);
                    }
                }
                
                if (count > 10) {
                    log.warn("Thread [{}]에 ThreadLocal Entry {}개 발견!", 
                            thread.getName(), count);
                }
            }
        } catch (Exception e) {
            log.debug("Thread {} 분석 실패", thread.getName());
        }
    }
}
```

#### 해결 방법
```java
// 1. finally 블록 사용
try {
    threadLocal.set(value);
    // 비즈니스 로직
} finally {
    threadLocal.remove();
}

// 2. Filter로 자동 정리
@Component
public class ThreadLocalCleanupFilter implements Filter {
    private static final Set<ThreadLocal<?>> MANAGED = ConcurrentHashMap.newKeySet();
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        try {
            chain.doFilter(request, response);
        } finally {
            for (ThreadLocal<?> tl : MANAGED) {
                tl.remove();
            }
        }
    }
}
```

### 6.2 @Async 메서드가 동기적으로 실행되는 문제

#### 원인: Self-invocation
```java
@Service
public class MyService {
    @Async
    public void asyncMethod() { }
    
    public void callAsync() {
        this.asyncMethod();  // ⚠️ 프록시를 거치지 않음 - 동기 실행!
    }
}
```

#### 해결
- 별도 Bean으로 분리
- ApplicationContext에서 프록시 획득
- @EnableAsync 설정 확인

---

## 7. 유명 라이브러리의 동시성 패턴

### 7.1 Java ForkJoinPool
```java
public class ForkJoinQuickSort extends RecursiveAction {
    @Override
    protected void compute() {
        if (right - left < THRESHOLD) {
            Arrays.sort(array, left, right);
        } else {
            int pivot = partition(array, left, right);
            
            ForkJoinQuickSort leftTask = new ForkJoinQuickSort(array, left, pivot);
            ForkJoinQuickSort rightTask = new ForkJoinQuickSort(array, pivot + 1, right);
            
            leftTask.fork();
            rightTask.fork();
            
            leftTask.join();   // 왼쪽 완료 대기
            rightTask.join();  // 오른쪽 완료 대기
        }
    }
}
```

### 7.2 Spring Batch 병렬 처리
```java
@Configuration
public class ParallelJobConfig {
    @Bean
    public Flow splitFlow() {
        return new FlowBuilder<SimpleFlow>("splitFlow")
            .split(taskExecutor())  // 병렬 실행
            .add(flow1(), flow2(), flow3())
            .build();  // 내부적으로 join()으로 동기화
    }
}
```

### 7.3 Apache Hadoop MapReduce
```java
public class LocalJobRunner {
    private class Job extends Thread {
        public void run() {
            // Map 단계
            for (Thread mapThread : mapThreads) {
                mapThread.start();
            }
            for (Thread mapThread : mapThreads) {
                mapThread.join();  // 모든 Map 완료 대기
            }
            
            // Reduce 단계
            for (Thread reduceThread : reduceThreads) {
                reduceThread.start();
            }
            for (Thread reduceThread : reduceThreads) {
                reduceThread.join();  // 모든 Reduce 완료 대기
            }
        }
    }
}
```

### 7.4 JVM Shutdown Hook
```java
class ApplicationShutdownHooks {
    static void runHooks() {
        for (Thread hook : hooks) {
            hook.start();
        }
        for (Thread hook : hooks) {
            hook.join();  // 모든 shutdown hook 완료 대기
        }
    }
}
```

---

## 📊 학습 체크리스트

### Basic Level ✅
- [ ] Happens-Before 5가지 규칙 이해
- [ ] ThreadLocal 기본 사용법
- [ ] Thread Pool에서 remove() 필요성
- [ ] @Async와 트랜잭션 분리 이유

### Intermediate Level 🟡
- [ ] WeakReference 동작 원리
- [ ] ThreadLocalMap 내부 구조
- [ ] 메모리 누수 진단 방법
- [ ] 트랜잭션 전파 패턴

### Expert Level 🔴
- [ ] JMM의 메모리 배리어
- [ ] Virtual Thread와 ThreadLocal
- [ ] 분산 트랜잭션 패턴
- [ ] 커스텀 동시성 도구 구현

---

## 💡 핵심 요약

1. **Happens-Before는 동시성의 기초**: 메모리 가시성과 실행 순서 보장
2. **ThreadLocal은 양날의 검**: 편리하지만 메모리 누수 위험
3. **@Async와 트랜잭션은 분리**: 스레드 경계를 넘는 트랜잭션은 불가능
4. **join()은 동기화의 핵심**: Fork-Join 패턴의 기본
5. **항상 정리하라**: Thread Pool 환경에서 remove()는 필수

---

## 📚 추가 학습 자료

- [Java Concurrency in Practice](https://jcip.net/)
- [JVM Memory Model Specification](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html)
- [Spring Framework Documentation - Async](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#scheduling)
- [Project Loom - Virtual Threads](https://openjdk.org/projects/loom/)

---

*작성일: 2024*  
*난이도: 시니어 개발자 (5-8년차)*  
*학습 시간: 약 4-6시간*