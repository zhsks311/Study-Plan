# ğŸ“š Java ë™ì‹œì„±ê³¼ ë©€í‹°ìŠ¤ë ˆë“œ íŠ¸ëœì­ì…˜ ì™„ë²½ ê°€ì´ë“œ

> **1ì£¼ì°¨ 3ì¼ì°¨**: Java Concurrency, Thread Safety, Transaction in Multi-threaded Environment
> 
> 8ë…„ì°¨ ì‹œë‹ˆì–´ ê°œë°œìë¥¼ ìœ„í•œ ì‹¬í™” í•™ìŠµ ìë£Œ

---

## ğŸ“‹ ëª©ì°¨

1. [Java Memory Modelê³¼ Happens-Before](#1-java-memory-modelê³¼-happens-before)
2. [Thread Safety ì„¤ê³„ ì›ì¹™](#2-thread-safety-ì„¤ê³„-ì›ì¹™)
3. [ThreadLocal ì™„ë²½ ì´í•´](#3-threadlocal-ì™„ë²½-ì´í•´)
4. [WeakReferenceì™€ ë©”ëª¨ë¦¬ ê´€ë¦¬](#4-weakreferenceì™€-ë©”ëª¨ë¦¬-ê´€ë¦¬)
5. [Spring @Asyncì™€ íŠ¸ëœì­ì…˜](#5-spring-asyncì™€-íŠ¸ëœì­ì…˜)
6. [ì‹¤ë¬´ íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ](#6-ì‹¤ë¬´-íŠ¸ëŸ¬ë¸”ìŠˆíŒ…-ê°€ì´ë“œ)
7. [ìœ ëª… ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ë™ì‹œì„± íŒ¨í„´](#7-ìœ ëª…-ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜-ë™ì‹œì„±-íŒ¨í„´)

---

## 1. Java Memory Modelê³¼ Happens-Before

### 1.1 CPUì™€ ë©”ëª¨ë¦¬ êµ¬ì¡°ì˜ ì´í•´

í˜„ëŒ€ CPUëŠ” ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ë‹¤ì¸µ ìºì‹œ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```
[CPU Core 1]          [CPU Core 2]
    â†“                     â†“
[L1 Cache]           [L1 Cache]  â† ê° ì½”ì–´ ì „ìš©
    â†“                     â†“
[L2 Cache]           [L2 Cache]
    â†“                     â†“
    [L3 Cache (ê³µìœ )]
           â†“
    [Main Memory]
```

**ë¬¸ì œì **: ê° ì½”ì–´ê°€ ë…ë¦½ì ì¸ ìºì‹œë¥¼ ê°€ì§€ë¯€ë¡œ **ê°€ì‹œì„±(Visibility)** ë¬¸ì œ ë°œìƒ

### 1.2 Happens-Before ê´€ê³„ë€?

**ì •ì˜**: "A happens-before B"ëŠ” Aì˜ ëª¨ë“  ê²°ê³¼ë¥¼ Bê°€ ë³¼ ìˆ˜ ìˆìŒì„ ë³´ì¥í•˜ëŠ” ë©”ëª¨ë¦¬ ê°€ì‹œì„± ê·œì¹™

### 1.3 Javaì˜ 5ê°€ì§€ í•µì‹¬ Happens-Before ê·œì¹™

#### 1) Program Order Rule
- ê°™ì€ ìŠ¤ë ˆë“œ ë‚´ì—ì„œëŠ” ì½”ë“œ ìˆœì„œëŒ€ë¡œ happens-before ê´€ê³„ ì„±ë¦½

#### 2) Volatile Variable Rule
```java
class VolatileExample {
    int a = 0;
    volatile boolean flag = false;
    
    // Thread A
    void writer() {
        a = 42;        // 1
        flag = true;   // 2 (volatile write - Memory Fence)
    }
    
    // Thread B  
    void reader() {
        if (flag) {    // 3 (volatile read)
            // flagê°€ trueë©´, aëŠ” ë°˜ë“œì‹œ 42 ë³´ì¥
            System.out.println(a); // 4
        }
    }
}
```

**í•µì‹¬**: volatile ì“°ê¸° ì´ì „ì˜ ëª¨ë“  ë³€ê²½ì‚¬í•­ì´ volatile ì½ê¸° ì´í›„ì— ê°€ì‹œí™”ë¨

#### 3) Thread Start Rule
```java
public class ThreadStartExample {
    static int sharedData = 0;
    static String message = null;
    
    public static void main(String[] args) {
        sharedData = 100;        // â‘  Main Thread
        message = "Hello";       // â‘¡ Main Thread
        
        Thread worker = new Thread(() -> {
            // start() í˜¸ì¶œ ë•ë¶„ì— â‘ , â‘¡ì˜ ê²°ê³¼ë¥¼ ë³¼ ìˆ˜ ìˆìŒ
            System.out.println(message);     // "Hello" ë³´ì¥
            System.out.println(sharedData);  // 100 ë³´ì¥
        });
        
        worker.start();  // â‘¢ ë©”ëª¨ë¦¬ ë™ê¸°í™” ì§€ì !
    }
}
```

**ì¤‘ìš”**: Thread.start()ëŠ” **ë‹¨ë°©í–¥** ë™ê¸°í™” (Parent â†’ Childë§Œ ë³´ì¥)

#### 4) Thread Join Rule
```java
public class ThreadJoinExample {
    static int result = 0;
    
    public static void main(String[] args) throws InterruptedException {
        Thread calculator = new Thread(() -> {
            for (int i = 1; i <= 100; i++) {
                result += i;  // ê³„ì‚° ìˆ˜í–‰
            }
        });
        
        calculator.start();
        calculator.join();  // calculatorì˜ ëª¨ë“  ë³€ê²½ì‚¬í•­ì´ ê°€ì‹œí™”ë¨
        
        System.out.println("Result: " + result);  // 5050 ë³´ì¥
    }
}
```

**Fork-Join íŒ¨í„´**:
```java
class ParallelProcessor {
    public int processInParallel(List<Integer> data) throws InterruptedException {
        final int[] leftSum = new int[1];
        final int[] rightSum = new int[1];
        
        Thread leftThread = new Thread(() -> 
            leftSum[0] = processLeft(data));
        Thread rightThread = new Thread(() -> 
            rightSum[0] = processRight(data));
        
        leftThread.start();
        rightThread.start();
        
        leftThread.join();   // ì™¼ìª½ ê²°ê³¼ ë™ê¸°í™”
        rightThread.join();  // ì˜¤ë¥¸ìª½ ê²°ê³¼ ë™ê¸°í™”
        
        return leftSum[0] + rightSum[0];  // ì•ˆì „í•˜ê²Œ ì‚¬ìš© ê°€ëŠ¥
    }
}
```

#### 5) Synchronized Rule
```java
class BankAccount {
    private int balance = 0;
    private final Object lock = new Object();
    
    void deposit(int amount) {
        synchronized (lock) {
            balance += amount;
        }  // unlock: ëª¨ë“  ë³€ê²½ì‚¬í•­ flush
    }
    
    int getBalance() {
        synchronized (lock) {  // lock: ì´ì „ unlockì˜ ëª¨ë“  ë³€ê²½ì‚¬í•­ visible
            return balance;
        }
    }
}
```

**í•µì‹¬**: ê°™ì€ ë½ì— ëŒ€í•´, ì´ì „ unlockì€ ë‹¤ìŒ lockë³´ë‹¤ happens-before

---

## 2. Thread Safety ì„¤ê³„ ì›ì¹™

### 2.1 Immutability (ë¶ˆë³€ì„±)
- ê°ì²´ ìƒì„± í›„ ìƒíƒœ ë³€ê²½ ë¶ˆê°€
- Thread-safe by design
- ì¶”ê°€ ë™ê¸°í™” ë¶ˆí•„ìš”

### 2.2 Thread Confinement (ìŠ¤ë ˆë“œ í•œì •)
- **Stack Confinement**: ì§€ì—­ ë³€ìˆ˜ ì‚¬ìš©
- **ThreadLocal Storage**: ìŠ¤ë ˆë“œë³„ ë…ë¦½ ì €ì¥ì†Œ
- **Ad-hoc Confinement**: ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œë§Œ ì ‘ê·¼ ë³´ì¥

### 2.3 Safe Publication (ì•ˆì „í•œ ê³µê°œ)
- volatile í•„ë“œ ì‚¬ìš©
- final í•„ë“œ ì‚¬ìš©
- ë™ê¸°í™”ëœ ì ‘ê·¼ì ë©”ì„œë“œ

---

## 3. ThreadLocal ì™„ë²½ ì´í•´

### 3.1 ThreadLocalì´ë€?

**ë¹„ìœ **: ê° ìŠ¤ë ˆë“œê°€ ê°€ì§„ ê°œì¸ ì‚¬ë¬¼í•¨

```java
public class UserContext {
    private static final ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public static void setUser(User user) {
        currentUser.set(user);
    }
    
    public static User getUser() {
        return currentUser.get();
    }
    
    public static void clear() {
        currentUser.remove();  // ì¤‘ìš”: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
    }
}
```

### 3.2 ë‚´ë¶€ êµ¬ì¡°

```java
// java.lang.Thread í´ë˜ìŠ¤
public class Thread implements Runnable {
    // ê° Threadê°€ ìì‹ ë§Œì˜ ThreadLocalMapì„ ë³´ìœ 
    ThreadLocal.ThreadLocalMap threadLocals = null;
}

// ThreadLocalì˜ get() ë©”ì„œë“œ
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = t.threadLocals;  // Thread ê°ì²´ì—ì„œ ê°€ì ¸ì˜´
    
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            return (T)e.value;
        }
    }
    return setInitialValue();
}
```

**ë©”ëª¨ë¦¬ êµ¬ì¡°**:
```
Thread-1                    Thread-2
â”œâ”€ threadLocals            â”œâ”€ threadLocals
   (ThreadLocalMap)           (ThreadLocalMap)
   â”œâ”€ Entry[0]                â”œâ”€ Entry[0]
   â”‚  key: ThreadLocal@123    â”‚  key: ThreadLocal@123
   â”‚  value: "User1"          â”‚  value: "User2"
   â””â”€ Entry[1]                â””â”€ Entry[1]
      key: ThreadLocal@456       key: ThreadLocal@456
      value: "TxnA"              value: "TxnB"
```

### 3.3 Thread Poolì—ì„œì˜ ìœ„í—˜

```java
@RestController
public class UserController {
    private static final ThreadLocal<User> userContext = new ThreadLocal<>();
    
    @GetMapping("/api/user")
    public String handleRequest() {
        try {
            userContext.set(getCurrentUser());
            // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
            return "Success";
        } finally {
            userContext.remove();  // âš ï¸ í•„ìˆ˜! Thread Poolì—ì„œ ì¬ì‚¬ìš©ë˜ë¯€ë¡œ
        }
    }
}
```

**ë¬¸ì œ ì‹œë‚˜ë¦¬ì˜¤**:
1. Thread Poolì˜ ThreadëŠ” ì¬ì‚¬ìš©ë¨
2. remove()ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ë‹¤ìŒ ìš”ì²­ì—ì„œ ì´ì „ ë°ì´í„° ì ‘ê·¼ ê°€ëŠ¥
3. **ë³´ì•ˆ ë¬¸ì œ + ë©”ëª¨ë¦¬ ëˆ„ìˆ˜** ë°œìƒ

---

## 4. WeakReferenceì™€ ë©”ëª¨ë¦¬ ê´€ë¦¬

### 4.1 Javaì˜ Reference ì¢…ë¥˜

```java
// 1. Strong Reference (ì ˆëŒ€ GC ì•ˆë¨)
String strong = new String("Strong");

// 2. Weak Reference (GCì‹œ ì¦‰ì‹œ ìˆ˜ê±°)
WeakReference<String> weak = new WeakReference<>(new String("Weak"));

// 3. Soft Reference (ë©”ëª¨ë¦¬ ë¶€ì¡±ì‹œë§Œ GC)
SoftReference<String> soft = new SoftReference<>(new String("Soft"));

// 4. Phantom Reference (ì´ë¯¸ ìˆ˜ê±°ëœ ê°ì²´ ì¶”ì )
PhantomReference<String> phantom = new PhantomReference<>(new String("Phantom"), queue);
```

### 4.2 WeakReference ë™ì‘ ì›ë¦¬

**ì¼ìƒì  ë¹„ìœ **:
- **Strong Reference** = ì •ì‹ ì—´ì‡  (ì ˆëŒ€ ì§‘ ì² ê±° ë¶ˆê°€)
- **Weak Reference** = ì„ì‹œ ì¶œì…ì¦ (ì •ì‹ ì—´ì‡  ì—†ìœ¼ë©´ ì² ê±° ê°€ëŠ¥)

### 4.3 ThreadLocalì´ WeakReferenceë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ 

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
    
    Entry(ThreadLocal<?> k, Object v) {
        super(k);  // keyë¥¼ WeakReferenceë¡œ
        value = v; // valueëŠ” strong reference
    }
}
```

**ì´ìœ **: ThreadLocal ì¸ìŠ¤í„´ìŠ¤(key)ê°€ GCë˜ì–´ë„ Threadê°€ ì‚´ì•„ìˆìœ¼ë©´ valueê°€ ë©”ëª¨ë¦¬ì— ë‚¨ëŠ” ë¬¸ì œ ë°©ì§€

**í•˜ì§€ë§Œ ì£¼ì˜**:
- key(ThreadLocal)ëŠ” GC ê°€ëŠ¥
- valueëŠ” ì—¬ì „íˆ strong reference
- ë”°ë¼ì„œ **remove() í˜¸ì¶œ í•„ìˆ˜!**

---

## 5. Spring @Asyncì™€ íŠ¸ëœì­ì…˜

### 5.1 @Async + @Transactional ë¬¸ì œ

```java
@Service
public class OrderService {
    @Async
    @Transactional  // âš ï¸ ë™ì‘í•˜ì§€ ì•ŠìŒ!
    public void processOrder(Long orderId) {
        // ìƒˆë¡œìš´ ìŠ¤ë ˆë“œ = ìƒˆë¡œìš´ ThreadLocal = íŠ¸ëœì­ì…˜ ì»¨í…ìŠ¤íŠ¸ ì—†ìŒ
    }
}
```

**ë¬¸ì œ ì›ì¸**:
- Spring íŠ¸ëœì­ì…˜ì€ `TransactionSynchronizationManager`ì˜ ThreadLocal ì‚¬ìš©
- @AsyncëŠ” ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
- ThreadLocalì€ ìŠ¤ë ˆë“œê°„ ê³µìœ  ë¶ˆê°€

### 5.2 í•´ê²° íŒ¨í„´

#### íŒ¨í„´ 1: TransactionalEventListener ì‚¬ìš©
```java
@Service
@Transactional
public class OrderService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void createOrder(Order order) {
        orderRepository.save(order);
        eventPublisher.publishEvent(new OrderCreatedEvent(order));
    }
}

@Component
public class OrderEventListener {
    @Async
    @EventListener
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // íŠ¸ëœì­ì…˜ ì»¤ë°‹ í›„ ë¹„ë™ê¸° ì‹¤í–‰
        sendEmail(event.getOrder());
    }
}
```

#### íŒ¨í„´ 2: CompletableFuture í™œìš©
```java
@Service
public class OrderService {
    @Transactional
    public Order createOrder(Order order) {
        return orderRepository.save(order);
    }
    
    public CompletableFuture<Void> processOrderAsync(Long orderId) {
        return CompletableFuture.runAsync(() -> {
            // ë³„ë„ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì²˜ë¦¬
            orderProcessor.process(orderId);
        });
    }
}
```

#### íŒ¨í„´ 3: ë©”ì‹œì§€ í í™œìš©
```java
@Service
@Transactional
public class OrderService {
    public void createOrder(Order order) {
        orderRepository.save(order);
        kafkaTemplate.send("order-topic", order);  // íŠ¸ëœì­ì…˜ ì»¤ë°‹ í›„ ë°œì†¡
    }
}

@KafkaListener(topics = "order-topic")
public void processOrder(Order order) {
    // ë…ë¦½ì ì¸ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì²˜ë¦¬
}
```

---

## 6. ì‹¤ë¬´ íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ

### 6.1 ThreadLocal ë©”ëª¨ë¦¬ ëˆ„ìˆ˜

#### ì¦ìƒ
- OutOfMemoryError ë°œìƒ
- í™ ë¤í”„ì—ì„œ ThreadLocal ê°’ ëŒ€ëŸ‰ ë°œê²¬
- GC í›„ì—ë„ ë©”ëª¨ë¦¬ í•´ì œ ì•ˆë¨

#### ì›ì¸
```java
@RestController
public class LeakyController {
    private static ThreadLocal<byte[]> memoryLeaker = new ThreadLocal<>();
    
    @GetMapping("/leak")
    public String leak() {
        byte[] bigArray = new byte[10 * 1024 * 1024];  // 10MB
        memoryLeaker.set(bigArray);
        // âš ï¸ remove() í˜¸ì¶œ ì•ˆí•¨!
        return "Leaked 10MB";
    }
}
```

#### ëª¨ë‹ˆí„°ë§ ì½”ë“œ
```java
@Component
@Slf4j
public class ThreadLocalMonitor {
    
    @Scheduled(fixedDelay = 60000)
    public void checkThreadLocals() {
        Thread[] threads = new Thread[Thread.activeCount()];
        Thread.enumerate(threads);
        
        for (Thread thread : threads) {
            analyzeThread(thread);
        }
    }
    
    private void analyzeThread(Thread thread) {
        try {
            Field threadLocalsField = Thread.class.getDeclaredField("threadLocals");
            threadLocalsField.setAccessible(true);
            Object threadLocalMap = threadLocalsField.get(thread);
            
            if (threadLocalMap != null) {
                Class<?> tlmClass = threadLocalMap.getClass();
                Field tableField = tlmClass.getDeclaredField("table");
                tableField.setAccessible(true);
                Object[] table = (Object[]) tableField.get(threadLocalMap);
                
                int count = 0;
                long totalSize = 0;
                
                for (Object entry : table) {
                    if (entry != null) {
                        count++;
                        totalSize += estimateSize(entry);
                    }
                }
                
                if (count > 10) {
                    log.warn("Thread [{}]ì— ThreadLocal Entry {}ê°œ ë°œê²¬!", 
                            thread.getName(), count);
                }
            }
        } catch (Exception e) {
            log.debug("Thread {} ë¶„ì„ ì‹¤íŒ¨", thread.getName());
        }
    }
}
```

#### í•´ê²° ë°©ë²•
```java
// 1. finally ë¸”ë¡ ì‚¬ìš©
try {
    threadLocal.set(value);
    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
} finally {
    threadLocal.remove();
}

// 2. Filterë¡œ ìë™ ì •ë¦¬
@Component
public class ThreadLocalCleanupFilter implements Filter {
    private static final Set<ThreadLocal<?>> MANAGED = ConcurrentHashMap.newKeySet();
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        try {
            chain.doFilter(request, response);
        } finally {
            for (ThreadLocal<?> tl : MANAGED) {
                tl.remove();
            }
        }
    }
}
```

### 6.2 @Async ë©”ì„œë“œê°€ ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ë¬¸ì œ

#### ì›ì¸: Self-invocation
```java
@Service
public class MyService {
    @Async
    public void asyncMethod() { }
    
    public void callAsync() {
        this.asyncMethod();  // âš ï¸ í”„ë¡ì‹œë¥¼ ê±°ì¹˜ì§€ ì•ŠìŒ - ë™ê¸° ì‹¤í–‰!
    }
}
```

#### í•´ê²°
- ë³„ë„ Beanìœ¼ë¡œ ë¶„ë¦¬
- ApplicationContextì—ì„œ í”„ë¡ì‹œ íšë“
- @EnableAsync ì„¤ì • í™•ì¸

---

## 7. ìœ ëª… ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ë™ì‹œì„± íŒ¨í„´

### 7.1 Java ForkJoinPool
```java
public class ForkJoinQuickSort extends RecursiveAction {
    @Override
    protected void compute() {
        if (right - left < THRESHOLD) {
            Arrays.sort(array, left, right);
        } else {
            int pivot = partition(array, left, right);
            
            ForkJoinQuickSort leftTask = new ForkJoinQuickSort(array, left, pivot);
            ForkJoinQuickSort rightTask = new ForkJoinQuickSort(array, pivot + 1, right);
            
            leftTask.fork();
            rightTask.fork();
            
            leftTask.join();   // ì™¼ìª½ ì™„ë£Œ ëŒ€ê¸°
            rightTask.join();  // ì˜¤ë¥¸ìª½ ì™„ë£Œ ëŒ€ê¸°
        }
    }
}
```

### 7.2 Spring Batch ë³‘ë ¬ ì²˜ë¦¬
```java
@Configuration
public class ParallelJobConfig {
    @Bean
    public Flow splitFlow() {
        return new FlowBuilder<SimpleFlow>("splitFlow")
            .split(taskExecutor())  // ë³‘ë ¬ ì‹¤í–‰
            .add(flow1(), flow2(), flow3())
            .build();  // ë‚´ë¶€ì ìœ¼ë¡œ join()ìœ¼ë¡œ ë™ê¸°í™”
    }
}
```

### 7.3 Apache Hadoop MapReduce
```java
public class LocalJobRunner {
    private class Job extends Thread {
        public void run() {
            // Map ë‹¨ê³„
            for (Thread mapThread : mapThreads) {
                mapThread.start();
            }
            for (Thread mapThread : mapThreads) {
                mapThread.join();  // ëª¨ë“  Map ì™„ë£Œ ëŒ€ê¸°
            }
            
            // Reduce ë‹¨ê³„
            for (Thread reduceThread : reduceThreads) {
                reduceThread.start();
            }
            for (Thread reduceThread : reduceThreads) {
                reduceThread.join();  // ëª¨ë“  Reduce ì™„ë£Œ ëŒ€ê¸°
            }
        }
    }
}
```

### 7.4 JVM Shutdown Hook
```java
class ApplicationShutdownHooks {
    static void runHooks() {
        for (Thread hook : hooks) {
            hook.start();
        }
        for (Thread hook : hooks) {
            hook.join();  // ëª¨ë“  shutdown hook ì™„ë£Œ ëŒ€ê¸°
        }
    }
}
```

---

## ğŸ“Š í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Basic Level âœ…
- [ ] Happens-Before 5ê°€ì§€ ê·œì¹™ ì´í•´
- [ ] ThreadLocal ê¸°ë³¸ ì‚¬ìš©ë²•
- [ ] Thread Poolì—ì„œ remove() í•„ìš”ì„±
- [ ] @Asyncì™€ íŠ¸ëœì­ì…˜ ë¶„ë¦¬ ì´ìœ 

### Intermediate Level ğŸŸ¡
- [ ] WeakReference ë™ì‘ ì›ë¦¬
- [ ] ThreadLocalMap ë‚´ë¶€ êµ¬ì¡°
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì§„ë‹¨ ë°©ë²•
- [ ] íŠ¸ëœì­ì…˜ ì „íŒŒ íŒ¨í„´

### Expert Level ğŸ”´
- [ ] JMMì˜ ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´
- [ ] Virtual Threadì™€ ThreadLocal
- [ ] ë¶„ì‚° íŠ¸ëœì­ì…˜ íŒ¨í„´
- [ ] ì»¤ìŠ¤í…€ ë™ì‹œì„± ë„êµ¬ êµ¬í˜„

---

## ğŸ’¡ í•µì‹¬ ìš”ì•½

1. **Happens-BeforeëŠ” ë™ì‹œì„±ì˜ ê¸°ì´ˆ**: ë©”ëª¨ë¦¬ ê°€ì‹œì„±ê³¼ ì‹¤í–‰ ìˆœì„œ ë³´ì¥
2. **ThreadLocalì€ ì–‘ë‚ ì˜ ê²€**: í¸ë¦¬í•˜ì§€ë§Œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìœ„í—˜
3. **@Asyncì™€ íŠ¸ëœì­ì…˜ì€ ë¶„ë¦¬**: ìŠ¤ë ˆë“œ ê²½ê³„ë¥¼ ë„˜ëŠ” íŠ¸ëœì­ì…˜ì€ ë¶ˆê°€ëŠ¥
4. **join()ì€ ë™ê¸°í™”ì˜ í•µì‹¬**: Fork-Join íŒ¨í„´ì˜ ê¸°ë³¸
5. **í•­ìƒ ì •ë¦¬í•˜ë¼**: Thread Pool í™˜ê²½ì—ì„œ remove()ëŠ” í•„ìˆ˜

---

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

- [Java Concurrency in Practice](https://jcip.net/)
- [JVM Memory Model Specification](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html)
- [Spring Framework Documentation - Async](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#scheduling)
- [Project Loom - Virtual Threads](https://openjdk.org/projects/loom/)

---

*ì‘ì„±ì¼: 2024*  
*ë‚œì´ë„: ì‹œë‹ˆì–´ ê°œë°œì (5-8ë…„ì°¨)*  
*í•™ìŠµ ì‹œê°„: ì•½ 4-6ì‹œê°„*