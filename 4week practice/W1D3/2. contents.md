ğŸ¯ **ì§„ë‹¨ ê²°ê³¼: Basic~Intermediate (ğŸ”´~ğŸŸ¡)**

**ë¶„ì„:** volatileì˜ ê¸°ë³¸ ê°œë…ê³¼ @Asyncì˜ ë™ì‘ ì›ë¦¬ëŠ” ì´í•´í•˜ê³  ìˆìœ¼ë‚˜, ë™ì‹œì„±ì˜ ì´ë¡ ì  ê¸°ë°˜ê³¼ ì‹¤ë¬´ íŒ¨í„´ì— ëŒ€í•œ ì²´ê³„ì ì¸ í•™ìŠµì´ í•„ìš”í•©ë‹ˆë‹¤. íŠ¹íˆ ThreadLocalê³¼ íŠ¸ëœì­ì…˜ ì „íŒŒ ë¬¸ì œëŠ” ì‹¤ë¬´ì—ì„œ ìì£¼ ë§ˆì£¼ì¹˜ëŠ” ì¤‘ìš”í•œ ì£¼ì œì…ë‹ˆë‹¤.

---

## **[3ë‹¨ê³„] ë§ì¶¤í˜• í•™ìŠµ ìë£Œ**

### ğŸ¯ **ì˜¤ëŠ˜ ì§‘ì¤‘í•  ë‚´ìš©: ë™ì‹œì„±ì˜ ê¸°ì´ˆë¶€í„° ì‹¤ë¬´ íŒ¨í„´ê¹Œì§€**

---

## **1. ğŸ“– Happens-Before: ë™ì‹œì„±ì˜ í•µì‹¬ ê·œì¹™**

### **1.1 ì™œ Happens-Beforeê°€ ì¤‘ìš”í•œê°€?**

**ë¬¸ì œ ìƒí™©ì„ ìƒìƒí•´ë³´ì„¸ìš”:**

```
Thread A: flag = true;
Thread B: if(flag) { doSomething(); }
```

ì–¸ëœ» ë³´ë©´ Thread Bê°€ flagë¥¼ í™•ì¸í•  ë•Œ trueë¥¼ ë³¼ ê²ƒ ê°™ì§€ë§Œ, **ì‹¤ì œë¡œëŠ” ê·¸ë ‡ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.** ì™œì¼ê¹Œìš”?

### **1.2 CPUì™€ ë©”ëª¨ë¦¬ì˜ ì§„ì‹¤**

í˜„ëŒ€ CPUëŠ” ì„±ëŠ¥ì„ ìœ„í•´ ì—¬ëŸ¬ ê³„ì¸µì˜ ìºì‹œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```
[CPU Core 1]          [CPU Core 2]
    â†“                     â†“
[L1 Cache]           [L1 Cache]  â† ê° ì½”ì–´ë§Œì˜ ìºì‹œ
    â†“                     â†“
[L2 Cache]           [L2 Cache]
    â†“                     â†“
    [L3 Cache (ê³µìœ )]
           â†“
    [Main Memory]
```

**ì—¬ê¸°ì„œ ë°œìƒí•˜ëŠ” ë¬¸ì œ:**

- Thread Aê°€ flag = trueë¥¼ ì‹¤í–‰í•´ë„ Core 1ì˜ ìºì‹œì—ë§Œ ê¸°ë¡ë  ìˆ˜ ìˆìŒ
- Thread BëŠ” Core 2ì—ì„œ ì‹¤í–‰ë˜ë©° ìì‹ ì˜ ìºì‹œì—ì„œ ì—¬ì „íˆ falseë¥¼ ë³¼ ìˆ˜ ìˆìŒ
- ì´ê²ƒì´ ë°”ë¡œ **ê°€ì‹œì„±(Visibility) ë¬¸ì œ**ì…ë‹ˆë‹¤

### **1.3 Happens-Before ê´€ê³„ì˜ ì •ì˜**

**Happens-BeforeëŠ” "ì¼ì–´ë‚œ ì¼ì„ ë³¼ ìˆ˜ ìˆìŒì„ ë³´ì¥"í•˜ëŠ” ê·œì¹™ì…ë‹ˆë‹¤.**

A happens-before Bë¼ëŠ” ê²ƒì€:

1. Aì˜ ëª¨ë“  ê²°ê³¼ë¥¼ Bê°€ ë³¼ ìˆ˜ ìˆìŒì„ ë³´ì¥
2. ë©”ëª¨ë¦¬ ê°€ì‹œì„±ê³¼ ì‹¤í–‰ ìˆœì„œë¥¼ ëª¨ë‘ ë³´ì¥

### **1.4 Javaì˜ Happens-Before ê·œì¹™ë“¤**

**1) Program Order Rule**

- ê°™ì€ ìŠ¤ë ˆë“œ ë‚´ì—ì„œëŠ” ì½”ë“œ ìˆœì„œëŒ€ë¡œ happens-before ê´€ê³„ ì„±ë¦½

**2) Volatile Variable Rule** â† ë‹¹ì‹ ì´ ì•Œê³  ìˆëŠ” ë¶€ë¶„!

- volatile ë³€ìˆ˜ ì“°ê¸°ëŠ” ê·¸ ì´í›„ ì½ê¸°ë³´ë‹¤ happens-before
- ëª¨ë“  CPU ìºì‹œë¥¼ ë™ê¸°í™”í•˜ì—¬ ìµœì‹  ê°’ ë³´ì¥

**3) Thread Start Rule**

- thread.start()ëŠ” í•´ë‹¹ ìŠ¤ë ˆë“œì˜ ëª¨ë“  ë™ì‘ë³´ë‹¤ happens-before

**4) Thread Join Rule**

- ìŠ¤ë ˆë“œì˜ ëª¨ë“  ë™ì‘ì€ thread.join() ë¦¬í„´ë³´ë‹¤ happens-before

**5) Synchronized Rule**

- unlockì€ ê°™ì€ ë½ì˜ ì´í›„ lockë³´ë‹¤ happens-before

### **1.5 volatileì˜ ì§„ì •í•œ ì˜ë¯¸**

ë‹¹ì‹ ì´ ì•Œê³  ìˆëŠ” "ìºì‹œë¥¼ ê±°ì¹˜ì§€ ì•Šê³  ì‹¤ì œ ê°’ ì ‘ê·¼"ì€ ì •í™•í•©ë‹ˆë‹¤!
í•˜ì§€ë§Œ volatileì€ ë” ë§ì€ ì¼ì„ í•©ë‹ˆë‹¤:

```java
class Example {
    int a = 0;
    volatile boolean flag = false;

    // Thread A
    void writer() {
        a = 42;        // 1
        flag = true;   // 2 (volatile write)
    }

    // Thread B
    void reader() {
        if (flag) {    // 3 (volatile read)
            // flagê°€ trueë©´, aëŠ” ë°˜ë“œì‹œ 42
            System.out.println(a); // 4
        }
    }
}
```

**volatileì˜ ìˆ¨ê²¨ì§„ íš¨ê³¼:**

- flagë¥¼ volatileë¡œ ì„ ì–¸í•˜ë©´, flag ì“°ê¸° ì´ì „ì˜ ëª¨ë“  ë³€ê²½ì‚¬í•­(a = 42)ë„ í•¨ê»˜ ê°€ì‹œí™”ë¨
- ì´ë¥¼ **Memory Fence** ë˜ëŠ” **Memory Barrier**ë¼ê³  í•¨

---

## **2. ğŸ”’ ThreadLocal: ìŠ¤ë ˆë“œë§Œì˜ ë¹„ë°€ ê³µê°„**

### **2.1 ThreadLocalì´ í•´ê²°í•˜ëŠ” ë¬¸ì œ**

**ìƒí™©:** ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ëª¨ë“  ë©”ì„œë“œê°€ í˜„ì¬ ì‚¬ìš©ì ì •ë³´ë¥¼ í•„ìš”ë¡œ í•¨

**ë‚˜ìœ í•´ê²°ì±…:** ëª¨ë“  ë©”ì„œë“œì— User íŒŒë¼ë¯¸í„° ì¶”ê°€

```java
void methodA(User user, ...) { methodB(user, ...); }
void methodB(User user, ...) { methodC(user, ...); }
// íŒŒë¼ë¯¸í„° ì§€ì˜¥!
```

**ThreadLocal í•´ê²°ì±…:**

```java
public class UserContext {
    private static ThreadLocal<User> currentUser = new ThreadLocal<>();

    public static void setUser(User user) {
        currentUser.set(user);
    }

    public static User getUser() {
        return currentUser.get();
    }
}
```

### **2.2 ThreadLocalì˜ ë‚´ë¶€ êµ¬ì¡°**

ê° Thread ê°ì²´ëŠ” ìì‹ ë§Œì˜ ThreadLocalMapì„ ê°€ì§‘ë‹ˆë‹¤:

```
Thread 1                    Thread 2
â”œâ”€ threadLocals            â”œâ”€ threadLocals
   (ThreadLocalMap)           (ThreadLocalMap)
   â”œâ”€ Entry[0]                â”œâ”€ Entry[0]
   â”‚  key: ThreadLocal@123    â”‚  key: ThreadLocal@123
   â”‚  value: "User1"          â”‚  value: "User2"
   â””â”€ Entry[1]                â””â”€ Entry[1]
      key: ThreadLocal@456       key: ThreadLocal@456
      value: "TxnA"              value: "TxnB"
```

### **2.3 WeakReferenceì˜ ë¹„ë°€**

**ì™œ ThreadLocalMapì˜ keyëŠ” WeakReferenceì¼ê¹Œ?**

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
    Entry(ThreadLocal<?> k, Object v) {
        super(k);  // keyë¥¼ WeakReferenceë¡œ
        value = v; // valueëŠ” strong reference
    }
}
```

**ì´ìœ :** ThreadLocal ê°ì²´ê°€ GCë˜ì–´ë„ Threadê°€ ì‚´ì•„ìˆìœ¼ë©´ valueê°€ ë©”ëª¨ë¦¬ì— ê³„ì† ë‚¨ëŠ” ë¬¸ì œ ë°©ì§€

### **2.4 Thread Poolì—ì„œì˜ ìœ„í—˜**

**ë¬¸ì œ ì‹œë‚˜ë¦¬ì˜¤:**

```java
@RestController
public class UserController {
    @GetMapping("/user")
    public String getUser() {
        UserContext.setUser(currentUser);
        // ... ì²˜ë¦¬ ...
        // UserContext.clear()ë¥¼ ê¹œë¹¡í–ˆë‹¤!
    }
}
```

**ë¬´ìŠ¨ ì¼ì´ ë°œìƒí•˜ë‚˜ìš”?**

1. Thread Poolì˜ ThreadëŠ” ì¬ì‚¬ìš©ë¨
2. ë‹¤ìŒ ìš”ì²­ì´ ê°™ì€ Threadë¥¼ ì‚¬ìš©í•˜ë©´ ì´ì „ ì‚¬ìš©ì ì •ë³´ê°€ ë‚¨ì•„ìˆìŒ
3. **ë³´ì•ˆ ë¬¸ì œ ë°œìƒ!** ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì •ë³´ ìœ ì¶œ ê°€ëŠ¥

**í•´ê²°ì±…:**

```java
try {
    UserContext.setUser(user);
    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
} finally {
    UserContext.clear(); // ë°˜ë“œì‹œ ì •ë¦¬!
}
```

---

## **3. ğŸ”„ @Asyncì™€ íŠ¸ëœì­ì…˜ì˜ í•¨ì •**

### **3.1 ì™œ @Transactional + @Asyncê°€ ë¬¸ì œì¸ê°€?**

ë‹¹ì‹ ì˜ ì´í•´ê°€ ì •í™•í•©ë‹ˆë‹¤! ìƒˆë¡œìš´ ìŠ¤ë ˆë“œ = ë³„ê°œì˜ íŠ¸ëœì­ì…˜

**êµ¬ì²´ì ì¸ ë©”ì»¤ë‹ˆì¦˜:**

```
Main Thread                 Async Thread
â”œâ”€ Transaction Context      â”œâ”€ (No Transaction Context)
â”œâ”€ DB Connection            â”œâ”€ (No Connection)
â””â”€ ThreadLocal ë³€ìˆ˜ë“¤        â””â”€ (ë¹„ì–´ìˆëŠ” ThreadLocal)
```

### **3.2 íŠ¸ëœì­ì…˜ ì „íŒŒê°€ ì•ˆ ë˜ëŠ” ì´ìœ **

Springì˜ íŠ¸ëœì­ì…˜ì€ **ThreadLocal**ì— ì €ì¥ë©ë‹ˆë‹¤:

- `TransactionSynchronizationManager`ê°€ ThreadLocal ì‚¬ìš©
- ìƒˆ ìŠ¤ë ˆë“œëŠ” ì´ ì •ë³´ì— ì ‘ê·¼ ë¶ˆê°€

### **3.3 ì‹¤ë¬´ í•´ê²° íŒ¨í„´ë“¤**

**íŒ¨í„´ 1: íŠ¸ëœì­ì…˜ ì™„ë£Œ í›„ ë¹„ë™ê¸° ì‹¤í–‰**

```java
@Service
@Transactional
public class OrderService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;

    public void createOrder(Order order) {
        // 1. DB ì €ì¥ (íŠ¸ëœì­ì…˜ ë‚´)
        orderRepository.save(order);

        // 2. ì´ë²¤íŠ¸ ë°œí–‰ (íŠ¸ëœì­ì…˜ ì»¤ë°‹ í›„ ì‹¤í–‰ë¨)
        eventPublisher.publishEvent(new OrderCreatedEvent(order));
    }
}

@Component
public class OrderEventListener {
    @Async
    @EventListener
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // íŠ¸ëœì­ì…˜ ì»¤ë°‹ í›„ ë¹„ë™ê¸° ì‹¤í–‰
        sendEmail(event.getOrder());
    }
}
```

**íŒ¨í„´ 2: CompletableFutureë¡œ ëª…ì‹œì  ì œì–´**

```java
@Service
public class OrderService {
    @Transactional
    public Order createOrder(Order order) {
        Order saved = orderRepository.save(order);
        return saved;
    }

    public CompletableFuture<Void> processOrderAsync(Long orderId) {
        return CompletableFuture.runAsync(() -> {
            // ìƒˆ íŠ¸ëœì­ì…˜ì—ì„œ ì²˜ë¦¬
            orderProcessor.process(orderId);
        });
    }
}
```

**íŒ¨í„´ 3: ë©”ì‹œì§€ í í™œìš©**

```java
@Service
@Transactional
public class OrderService {
    public void createOrder(Order order) {
        orderRepository.save(order);
        // íŠ¸ëœì­ì…˜ ì»¤ë°‹ í›„ ë©”ì‹œì§€ ë°œì†¡
        kafkaTemplate.send("order-topic", order);
    }
}

// ë³„ë„ ì„œë¹„ìŠ¤/ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬
@KafkaListener(topics = "order-topic")
public void processOrder(Order order) {
    // ë…ë¦½ì ì¸ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì²˜ë¦¬
}
```

---

## **4. ğŸ¯ ì‹¤ì „ íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ì‹œë‚˜ë¦¬ì˜¤**

### **ì‹œë‚˜ë¦¬ì˜¤ 1: "ì™œ @Async ë©”ì„œë“œê°€ ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ë‚˜ìš”?"**

**ì›ì¸:** Self-invocation ë¬¸ì œ

```java
@Service
public class MyService {
    @Async
    public void asyncMethod() { } // ì‹¤í–‰ ì•ˆë¨!

    public void callAsync() {
        this.asyncMethod(); // í”„ë¡ì‹œë¥¼ ê±°ì¹˜ì§€ ì•ŠìŒ
    }
}
```

**í•´ê²°:**

- ë³„ë„ Beanìœ¼ë¡œ ë¶„ë¦¬
- @EnableAsync + AsyncConfigurer ì„¤ì •
- ApplicationContextì—ì„œ í”„ë¡ì‹œ íšë“

### **ì‹œë‚˜ë¦¬ì˜¤ 2: "ThreadLocal ë©”ëª¨ë¦¬ ëˆ„ìˆ˜"**

**ì¦ìƒ:** OutOfMemoryError, í™ ë¤í”„ì—ì„œ ThreadLocal ê°’ ëŒ€ëŸ‰ ë°œê²¬

**ì§„ë‹¨ ë°©ë²•:**

```java
// ëª¨ë‹ˆí„°ë§ ì½”ë“œ
@Component
public class ThreadLocalMonitor {
    @Scheduled(fixedDelay = 60000)
    public void checkThreadLocals() {
        Thread[] threads = new Thread[Thread.activeCount()];
        Thread.enumerate(threads);

        for (Thread t : threads) {
            // Reflectionìœ¼ë¡œ threadLocals í•„ë“œ ì ‘ê·¼
            // í¬ê¸° í™•ì¸ ë° ê²½ê³ 
        }
    }
}
```

---

## **5. ğŸ“Š ë‹¤ìŒ í•™ìŠµ ì¤€ë¹„**

**ë‚´ì¼ í•™ìŠµí•  ë‚´ìš©:** Springì˜ í•µì‹¬ ì›ë¦¬ (IoC/DI, AOP)ì™€ íŠ¸ëœì­ì…˜ ì „íŒŒ

**ì˜¤ëŠ˜ ë°°ìš´ ë‚´ìš©ê³¼ì˜ ì—°ê²°:**

- ThreadLocalì´ íŠ¸ëœì­ì…˜ ì „íŒŒì— ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€
- AOP Proxyê°€ @Async, @Transactionalì— ë¯¸ì¹˜ëŠ” ì˜í–¥
- íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€ê³¼ ë™ì‹œì„± ì œì–´ì˜ ê´€ê³„

**ë³µìŠµ í¬ì¸íŠ¸:**

1. Happens-Before ê·œì¹™ 5ê°€ì§€ë¥¼ ì•”ê¸°í•˜ì„¸ìš”
2. ThreadLocalì„ ì‚¬ìš©í•  ë•Œ finally ë¸”ë¡ì—ì„œ clear()í•˜ëŠ” ìŠµê´€ì„ ë“¤ì´ì„¸ìš”
3. @Asyncì™€ íŠ¸ëœì­ì…˜ì„ ë¶„ë¦¬í•˜ëŠ” 3ê°€ì§€ íŒ¨í„´ì„ ì´í•´í•˜ì„¸ìš”

**ì§ˆë¬¸ ìˆìœ¼ì‹ ê°€ìš”? íŠ¹ì • ë¶€ë¶„ì„ ë” ê¹Šì´ ë‹¤ë£¨ê³  ì‹¶ìœ¼ì‹œë©´ ë§ì”€í•´ì£¼ì„¸ìš”!**
