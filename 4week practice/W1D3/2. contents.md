🎯 **진단 결과: Basic~Intermediate (🔴~🟡)**

**분석:** volatile의 기본 개념과 @Async의 동작 원리는 이해하고 있으나, 동시성의 이론적 기반과 실무 패턴에 대한 체계적인 학습이 필요합니다. 특히 ThreadLocal과 트랜잭션 전파 문제는 실무에서 자주 마주치는 중요한 주제입니다.

---

## **[3단계] 맞춤형 학습 자료**

### 🎯 **오늘 집중할 내용: 동시성의 기초부터 실무 패턴까지**

---

## **1. 📖 Happens-Before: 동시성의 핵심 규칙**

### **1.1 왜 Happens-Before가 중요한가?**

**문제 상황을 상상해보세요:**

```
Thread A: flag = true;
Thread B: if(flag) { doSomething(); }
```

언뜻 보면 Thread B가 flag를 확인할 때 true를 볼 것 같지만, **실제로는 그렇지 않을 수 있습니다.** 왜일까요?

### **1.2 CPU와 메모리의 진실**

현대 CPU는 성능을 위해 여러 계층의 캐시를 사용합니다:

```
[CPU Core 1]          [CPU Core 2]
    ↓                     ↓
[L1 Cache]           [L1 Cache]  ← 각 코어만의 캐시
    ↓                     ↓
[L2 Cache]           [L2 Cache]
    ↓                     ↓
    [L3 Cache (공유)]
           ↓
    [Main Memory]
```

**여기서 발생하는 문제:**

- Thread A가 flag = true를 실행해도 Core 1의 캐시에만 기록될 수 있음
- Thread B는 Core 2에서 실행되며 자신의 캐시에서 여전히 false를 볼 수 있음
- 이것이 바로 **가시성(Visibility) 문제**입니다

### **1.3 Happens-Before 관계의 정의**

**Happens-Before는 "일어난 일을 볼 수 있음을 보장"하는 규칙입니다.**

A happens-before B라는 것은:

1. A의 모든 결과를 B가 볼 수 있음을 보장
2. 메모리 가시성과 실행 순서를 모두 보장

### **1.4 Java의 Happens-Before 규칙들**

**1) Program Order Rule**

- 같은 스레드 내에서는 코드 순서대로 happens-before 관계 성립

**2) Volatile Variable Rule** ← 당신이 알고 있는 부분!

- volatile 변수 쓰기는 그 이후 읽기보다 happens-before
- 모든 CPU 캐시를 동기화하여 최신 값 보장

**3) Thread Start Rule**

- thread.start()는 해당 스레드의 모든 동작보다 happens-before

**4) Thread Join Rule**

- 스레드의 모든 동작은 thread.join() 리턴보다 happens-before

**5) Synchronized Rule**

- unlock은 같은 락의 이후 lock보다 happens-before

### **1.5 volatile의 진정한 의미**

당신이 알고 있는 "캐시를 거치지 않고 실제 값 접근"은 정확합니다!
하지만 volatile은 더 많은 일을 합니다:

```java
class Example {
    int a = 0;
    volatile boolean flag = false;

    // Thread A
    void writer() {
        a = 42;        // 1
        flag = true;   // 2 (volatile write)
    }

    // Thread B
    void reader() {
        if (flag) {    // 3 (volatile read)
            // flag가 true면, a는 반드시 42
            System.out.println(a); // 4
        }
    }
}
```

**volatile의 숨겨진 효과:**

- flag를 volatile로 선언하면, flag 쓰기 이전의 모든 변경사항(a = 42)도 함께 가시화됨
- 이를 **Memory Fence** 또는 **Memory Barrier**라고 함

---

## **2. 🔒 ThreadLocal: 스레드만의 비밀 공간**

### **2.1 ThreadLocal이 해결하는 문제**

**상황:** 웹 애플리케이션에서 모든 메서드가 현재 사용자 정보를 필요로 함

**나쁜 해결책:** 모든 메서드에 User 파라미터 추가

```java
void methodA(User user, ...) { methodB(user, ...); }
void methodB(User user, ...) { methodC(user, ...); }
// 파라미터 지옥!
```

**ThreadLocal 해결책:**

```java
public class UserContext {
    private static ThreadLocal<User> currentUser = new ThreadLocal<>();

    public static void setUser(User user) {
        currentUser.set(user);
    }

    public static User getUser() {
        return currentUser.get();
    }
}
```

### **2.2 ThreadLocal의 내부 구조**

각 Thread 객체는 자신만의 ThreadLocalMap을 가집니다:

```
Thread 1                    Thread 2
├─ threadLocals            ├─ threadLocals
   (ThreadLocalMap)           (ThreadLocalMap)
   ├─ Entry[0]                ├─ Entry[0]
   │  key: ThreadLocal@123    │  key: ThreadLocal@123
   │  value: "User1"          │  value: "User2"
   └─ Entry[1]                └─ Entry[1]
      key: ThreadLocal@456       key: ThreadLocal@456
      value: "TxnA"              value: "TxnB"
```

### **2.3 WeakReference의 비밀**

**왜 ThreadLocalMap의 key는 WeakReference일까?**

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
    Entry(ThreadLocal<?> k, Object v) {
        super(k);  // key를 WeakReference로
        value = v; // value는 strong reference
    }
}
```

**이유:** ThreadLocal 객체가 GC되어도 Thread가 살아있으면 value가 메모리에 계속 남는 문제 방지

### **2.4 Thread Pool에서의 위험**

**문제 시나리오:**

```java
@RestController
public class UserController {
    @GetMapping("/user")
    public String getUser() {
        UserContext.setUser(currentUser);
        // ... 처리 ...
        // UserContext.clear()를 깜빡했다!
    }
}
```

**무슨 일이 발생하나요?**

1. Thread Pool의 Thread는 재사용됨
2. 다음 요청이 같은 Thread를 사용하면 이전 사용자 정보가 남아있음
3. **보안 문제 발생!** 다른 사용자의 정보 유출 가능

**해결책:**

```java
try {
    UserContext.setUser(user);
    // 비즈니스 로직
} finally {
    UserContext.clear(); // 반드시 정리!
}
```

---

## **3. 🔄 @Async와 트랜잭션의 함정**

### **3.1 왜 @Transactional + @Async가 문제인가?**

당신의 이해가 정확합니다! 새로운 스레드 = 별개의 트랜잭션

**구체적인 메커니즘:**

```
Main Thread                 Async Thread
├─ Transaction Context      ├─ (No Transaction Context)
├─ DB Connection            ├─ (No Connection)
└─ ThreadLocal 변수들        └─ (비어있는 ThreadLocal)
```

### **3.2 트랜잭션 전파가 안 되는 이유**

Spring의 트랜잭션은 **ThreadLocal**에 저장됩니다:

- `TransactionSynchronizationManager`가 ThreadLocal 사용
- 새 스레드는 이 정보에 접근 불가

### **3.3 실무 해결 패턴들**

**패턴 1: 트랜잭션 완료 후 비동기 실행**

```java
@Service
@Transactional
public class OrderService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;

    public void createOrder(Order order) {
        // 1. DB 저장 (트랜잭션 내)
        orderRepository.save(order);

        // 2. 이벤트 발행 (트랜잭션 커밋 후 실행됨)
        eventPublisher.publishEvent(new OrderCreatedEvent(order));
    }
}

@Component
public class OrderEventListener {
    @Async
    @EventListener
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 트랜잭션 커밋 후 비동기 실행
        sendEmail(event.getOrder());
    }
}
```

**패턴 2: CompletableFuture로 명시적 제어**

```java
@Service
public class OrderService {
    @Transactional
    public Order createOrder(Order order) {
        Order saved = orderRepository.save(order);
        return saved;
    }

    public CompletableFuture<Void> processOrderAsync(Long orderId) {
        return CompletableFuture.runAsync(() -> {
            // 새 트랜잭션에서 처리
            orderProcessor.process(orderId);
        });
    }
}
```

**패턴 3: 메시지 큐 활용**

```java
@Service
@Transactional
public class OrderService {
    public void createOrder(Order order) {
        orderRepository.save(order);
        // 트랜잭션 커밋 후 메시지 발송
        kafkaTemplate.send("order-topic", order);
    }
}

// 별도 서비스/스레드에서 처리
@KafkaListener(topics = "order-topic")
public void processOrder(Order order) {
    // 독립적인 트랜잭션으로 처리
}
```

---

## **4. 🎯 실전 트러블슈팅 시나리오**

### **시나리오 1: "왜 @Async 메서드가 동기적으로 실행되나요?"**

**원인:** Self-invocation 문제

```java
@Service
public class MyService {
    @Async
    public void asyncMethod() { } // 실행 안됨!

    public void callAsync() {
        this.asyncMethod(); // 프록시를 거치지 않음
    }
}
```

**해결:**

- 별도 Bean으로 분리
- @EnableAsync + AsyncConfigurer 설정
- ApplicationContext에서 프록시 획득

### **시나리오 2: "ThreadLocal 메모리 누수"**

**증상:** OutOfMemoryError, 힙 덤프에서 ThreadLocal 값 대량 발견

**진단 방법:**

```java
// 모니터링 코드
@Component
public class ThreadLocalMonitor {
    @Scheduled(fixedDelay = 60000)
    public void checkThreadLocals() {
        Thread[] threads = new Thread[Thread.activeCount()];
        Thread.enumerate(threads);

        for (Thread t : threads) {
            // Reflection으로 threadLocals 필드 접근
            // 크기 확인 및 경고
        }
    }
}
```

---

## **5. 📊 다음 학습 준비**

**내일 학습할 내용:** Spring의 핵심 원리 (IoC/DI, AOP)와 트랜잭션 전파

**오늘 배운 내용과의 연결:**

- ThreadLocal이 트랜잭션 전파에 어떻게 사용되는지
- AOP Proxy가 @Async, @Transactional에 미치는 영향
- 트랜잭션 격리 수준과 동시성 제어의 관계

**복습 포인트:**

1. Happens-Before 규칙 5가지를 암기하세요
2. ThreadLocal을 사용할 때 finally 블록에서 clear()하는 습관을 들이세요
3. @Async와 트랜잭션을 분리하는 3가지 패턴을 이해하세요

**질문 있으신가요? 특정 부분을 더 깊이 다루고 싶으시면 말씀해주세요!**
